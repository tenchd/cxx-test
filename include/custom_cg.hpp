#pragma once
#include <mkl.h>
#include <mkl_spblas.h>
#include "auxilliary.hpp"
#include <random>
// #include <vector>
// #include <iostream>
// #include <cassert>
// #include <math.h>

template <typename type_int>
void writeVectorToFile2(const std::vector<type_int>& vec, const std::string& filename) 
{
    std::ofstream outFile(filename);
    
    //std::cout << "opening file: " << filename << std::endl;

    if (!outFile) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return;
    }
    
    for (const type_int& element : vec) {
        outFile << element << "\n";
    }
    
    outFile.close();
}


template <typename type_int, typename type_data>
void remove_last_row_and_column(custom_space::sparse_matrix<type_int, type_data> &A) {
    // The matrix is assumed to be square.
    type_int n = A.num_rows;
    type_int new_n = n - 1;  // New dimension after removing last row and column

    std::vector<type_data> new_values;
    std::vector<type_int> new_row_indices;
    std::vector<type_int> new_col_ptrs(new_n + 1, 0);

    type_int k = 0;
    // Process columns 0 through new_n - 1 (skip the last column)
    for (type_int j = 0; j < new_n; j++) {
        new_col_ptrs[j] = k;
        // Loop through all entries in column j
        for (type_int idx = A.col_ptrs[j]; idx < A.col_ptrs[j + 1]; idx++) {
            // Only copy the entry if its row is less than new_n (i.e. skip the last row)
            if (A.row_indices[idx] < new_n) {
                new_values.push_back(A.values[idx]);
                new_row_indices.push_back(A.row_indices[idx]);
                k++;
            }
        }
    }
    
    new_col_ptrs[new_n] = k;

    // Update matrix dimensions and data
    A.num_rows = new_n;
    A.num_cols = new_n;
    A.values = std::move(new_values);
    A.row_indices = std::move(new_row_indices);
    A.col_ptrs = std::move(new_col_ptrs);
}

template <typename type_data>
void generate_zero_sum_vector(type_data *h_vec, size_t n, unsigned long seed) 
{
    std::mt19937 gen(seed);                     // Mersenne Twister RNG
    std::uniform_real_distribution<type_data> dist(0.0, 1.0); // Range [-1, 1]

    type_data sum = 0.0;
    for (size_t i = 0; i < n; i++) {
        h_vec[i] = dist(gen);
        sum += h_vec[i];
    }

    // // Adjust the vector so the sum of all entries is zero
    type_data mean = sum / n;
    for (size_t i = 0; i < n; i++) {
        h_vec[i] -= mean;
        
    }
}

template <typename type_data>
void enforce_zero_sum_vector(type_data *h_vec, size_t n) 
{
    //std::mt19937 gen(seed);                     // Mersenne Twister RNG
    //std::uniform_real_distribution<type_data> dist(0.0, 1.0); // Range [-1, 1]

    type_data sum = 0.0;
    for (size_t i = 0; i < n; i++) {
        //h_vec[i] = dist(gen);
        sum += h_vec[i];
    }

    // // Adjust the vector so the sum of all entries is zero
    type_data mean = sum / n;
    for (size_t i = 0; i < n; i++) {
        h_vec[i] -= mean;
        
    }
}

template <typename type_int, typename type_data>
std::vector<type_data> example_pcg_solver(custom_space::sparse_matrix<type_int, type_data> &A, custom_space::sparse_matrix<type_int, type_data> &M, type_data *diagonal, bool is_graph, std::vector<type_data>& right_hand_side) {
//void example_pcg_solver(custom_space::sparse_matrix<type_int, type_data> &A, custom_space::sparse_matrix<type_int, type_data> &M, type_data *diagonal, bool is_graph) {
    
    if(!is_graph)
    {
        remove_last_row_and_column<type_int, type_data>(A);
        remove_last_row_and_column<type_int, type_data>(M);
        printf("treated as physics problem\n");
    }
    else
    {
        printf("treated as graph problem\n");
    }

    printf("trimmed laplacian nnz: %d, trimmed factor nnz: %d\n", A.nonZeros(), M.nonZeros());
    type_int n = A.rows();
    // omp_set_num_threads(1);
    // mkl_set_num_threads(32);

    // printf("omp thread count: %d, mkl thread count: %d\n", omp_get_num_threads(), mkl_get_max_threads());
    // SPD, diagonally dominant matrix in CSR format (fully populated)
    std::vector<type_int> &row_ptr = A.col_ptrs;
    std::vector<type_int> &col_ind = A.row_indices;
    std::vector<type_data> &values = A.values;

    
     // Create MKL handle for A
     sparse_matrix_t A_handle = nullptr;
     matrix_descr descr_A = {SPARSE_MATRIX_TYPE_SYMMETRIC, SPARSE_FILL_MODE_FULL, SPARSE_DIAG_NON_UNIT};
 
     mkl_sparse_d_create_csr(&A_handle, SPARSE_INDEX_BASE_ZERO, n, n,
                              row_ptr.data(), row_ptr.data() + 1,
                              col_ind.data(), values.data());
 

    std::vector<type_data> dummy(n);
    generate_zero_sum_vector(dummy.data(), n, 0);
    //std::vector<type_data> b(n);
    //printf("DAVID %i",n);
    std::vector<type_data> b = right_hand_side;
    enforce_zero_sum_vector(b.data(), n);

    if(is_graph)
    {
        // printf("using rhs generated by multiply\n");
        // mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, A_handle, descr_A, dummy.data(), 0, b.data());
    }
    
   
    std::vector<type_data> x(n, 0.0); // initial guess
    std::vector<type_data> tmp(4 * n, 0.0);
    std::vector<type_int> ipar(128, 0);
    std::vector<type_data> dpar(128, 0.0);

    int RCI_request = 0;

    // Initialize the solver
    dcg_init(&n, x.data(), b.data(), &RCI_request, ipar.data(), dpar.data(), tmp.data());


    ipar[0] = n;       // size
    ipar[1] = 6;       // display error option
    ipar[3] = 0;       // iteration counter
    ipar[4] = 400;    // max iterations
    ipar[7] = 1;        // 0 means no check, otherwise means internally check max
    ipar[8] = 0;       // 0 means no check, otherwise means internally check norm
    ipar[9] = 1;       // 0 means no check, otherwise means user check
    ipar[10] = 1;      // preconditioning enabled

    dpar[0] = 2e-7; // tolerance



    dcg_check(&n, x.data(), b.data(), &RCI_request, ipar.data(), dpar.data(), tmp.data());

    
   
    // MKL handle for preconditioner M and MT
    sparse_matrix_t M_handle = nullptr;
    mkl_sparse_d_create_csr(&M_handle, SPARSE_INDEX_BASE_ZERO, n, n,
        M.col_ptrs.data(), M.col_ptrs.data() + 1,
        M.row_indices.data(), M.values.data());
    // for(int i = 0; i < 10; i++)
    // {
    //     printf("indices: %d\n", M.row_indices[i]);
    //     printf("ptrs: %d\n", M.col_ptrs[i]);
    // }

    sparse_matrix_t MT_handle = nullptr;
    mkl_sparse_d_create_csr(&MT_handle, SPARSE_INDEX_BASE_ZERO, n, n,
        M.col_ptrs.data(), M.col_ptrs.data() + 1,
        M.row_indices.data(), M.values.data());
    
    struct matrix_descr descr_M;
    descr_M.type = SPARSE_MATRIX_TYPE_TRIANGULAR;
    descr_M.mode = SPARSE_FILL_MODE_UPPER;
    descr_M.diag = SPARSE_DIAG_NON_UNIT;

    auto start = std::chrono::high_resolution_clock::now();
    // run inspector on MKL sparse
    // int stat = mkl_sparse_set_sv_hint(M_handle, SPARSE_OPERATION_TRANSPOSE, descr_M, 1);
    // stat = mkl_sparse_set_sv_hint(MT_handle, SPARSE_OPERATION_NON_TRANSPOSE, descr_M, 1);
    // stat = mkl_sparse_set_mv_hint(A_handle, SPARSE_OPERATION_NON_TRANSPOSE, descr_A, 1);
    
    // mkl_sparse_optimize(M_handle);
    // mkl_sparse_optimize(MT_handle);
    // mkl_sparse_optimize(A_handle);

    // Record end time
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the duration in seconds
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    std::cout << "Inspector time taken: " << duration.count() << " milliseconds" << std::endl;


    type_data *temp_for_pre = (type_data *)malloc(n * sizeof(type_data));
    

    start = std::chrono::high_resolution_clock::now();
    int counter = 0;
    while (true) 
    {
        dcg(&n, x.data(), b.data(), &RCI_request, ipar.data(), dpar.data(), tmp.data());
        if(counter % 50 == 0)
        {
            std::cout << "current step: " << ipar[3] << ", current residual norm: " << sqrt(dpar[4]) << "\n";
        }
        //printf("RCI_request: %d\n", RCI_request);
        if (RCI_request == 0) 
        {
            std::cout << "Converged. Iterations: " << ipar[3] << ", Final residual norm: " << sqrt(dpar[4]) << "\n";
            break;
        } 
        else if (RCI_request == 1) 
        {
            // Compute A * tmp[0:n] and store result in tmp[n:2n]
            mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, A_handle, descr_A, &tmp[0], 0.0, &tmp[n]);
        } 
        else if (RCI_request == 2) 
        {
            // double norm_r2 = 0.0;
            // for (int i = 2 * n; i < 3 * n; ++i)
            // {
            //     norm_r2 += tmp[i] * tmp[i]; // tmp[0:n] is r_k
            // }
            // //printf("norm: %f, ipar[9]: %d\n", sqrt(norm_r2), ipar[9]);
            // if (sqrt(norm_r2) < dpar[0]) 
            // {
            //     // Let dcg handle the stopping condition, do not set RCI_request manually
            //     continue;
            // }
            if(sqrt(dpar[4]) > sqrt(dpar[0]))
            {
                continue;
            }
            else
            {
                std::cout << "Converged. Iterations: " << ipar[3] << ", Final residual norm: " << sqrt(dpar[4]) << "\n";
                
                break;
            }
        } 
        else if(RCI_request == 3)
        {
            mkl_sparse_d_trsv(SPARSE_OPERATION_TRANSPOSE, 1.0, M_handle, descr_M, &tmp[2 * n], temp_for_pre);
            for(type_int i = 0; i < n; i++)
            {
                if(diagonal[i] != 0)
                {
                    temp_for_pre[i] = temp_for_pre[i] / diagonal[i];
                }
            }
            mkl_sparse_d_trsv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, MT_handle, descr_M, temp_for_pre, &tmp[3 * n]);
        }
        else 
        {
            std::cerr << "Unexpected RCI_request: " << RCI_request << "\n";
            break;
        }
        counter++;
    }
    // Record end time
    end = std::chrono::high_resolution_clock::now();

    // Calculate the duration in seconds
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    std::cout << "Solve time taken: " << duration.count() << " milliseconds" << std::endl;

    double norm_rhs = cblas_dnrm2(n, b.data(), 1);
    mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE, 1.0, A_handle, descr_A, x.data(), -1, b.data());
    printf("relative residual: %.12f\n", cblas_dnrm2(n, b.data(), 1) / norm_rhs);
    
    //for (auto i : x) {
    //    std::cout << i << ' ';
    //}
    //writeVectorToFile2(x, "x.data");
    mkl_sparse_destroy(A_handle);
    mkl_sparse_destroy(M_handle);
    mkl_sparse_destroy(MT_handle);

    // std::cout << "Solution x:\n";
    // for (double val : x)
    //     std::cout << val << " ";
    std::cout << "\n";

    return x;
}

